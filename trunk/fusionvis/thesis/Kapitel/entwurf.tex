%----------------------------------------------------------------%
% entwurf.tex						    			    										       %
%----------------------------------------------------------------%
\chapter{Entwurf eines Visualisierungsframeworks}
In diesem Kapitel werden der Entwurf eines Visualisierungsframeworks und eine prototypische Implementierung auf dessen Basis beschrieben. Dazu werden die einzelnen Komponenten des Frameworks erklärt und ihr Zusammenspiel erläutert. Basierend auf dem Wissen über die Bestandteile können die Möglichkeiten der Erweiterbarkeit und der Individualisierbarkeit skizziert werde. Die Grundlage hierfür stellt zum einen eine prototypische Implementierung einer Visualisierung einer militärischen Lage und des weiteren der Versuch, Daten des NDP [ABK] dreidimensional darzustellen.

Abschließend werden interessante Aspekte der Implementierung aufgezeigt, die neben den umgesetzten Implementierungsentscheidungen auch andere Wege aufzeigen sollen.

Dem Leser, der sich vorrangig für den entstandenen Prototyp interessiert, dem sei der Abschnitt \ref{ch:Prototyp} empfohlen. Die Details des Frameworks sollten für das Verständnis des Funktionsumfangs und die Bedienung keine Rolle spielen, können aber bei Bedarf nachgeschlagen werden.
\section{Design eines Visualisierungsframeworks}
Das Ergebnis dieser Arbeit soll nicht nur eine potentielle Visualisierungs-Umgebung sein, sonder ein Framework, das zum einen die Möglichkeit bietet, mit geringem Aufwand Daten anzeigen zu können und auf der anderen Seite aber umfangreiche Erweiterungsmöglichkeiten zulässt.
Wie das Framework konkret entworfen und umgesetzt wurde, soll im Folgenden dargestellt werden.
\subsection{Eingabedaten und Datenmodell}
Grundlage für die weitere Arbeit sollen Eingabedaten sein, die bestimmte Voraussetzungen erfüllen. Diese gestellten Bedingungen werden im Folgenden kurz beschrieben. Darauf basierend wird das Datenmodell erläutert, in das die Quelldaten überführt werden sollen.
\subsubsection{Eingabedaten}
\label{ch:Eingabedaten}
Um Daten dreidimensional visualisieren zu können, müssen diese bestimmte Voraussetzungen erfüllen. Diese sollen hier kurz aufgezeigt werden.
\paragraph{Identifizierbarkeit}
Unabhängig von der Art der Visualisierung ist es unabdingbar, dass jedes einzelne Datum identifizierbar ist. Aus diesem Grund sollte in den Quelldaten bereits eine eindeutige Benennung vorliegen. Sollte das nicht der Fall sein, muss dieser Misstand beim Importieren der Daten spätestens behoben werden. 
Probleme, die sich ergeben können, wenn diese Bedingung nicht beachtet wird, sind zum einen, dass keine aussagekräftigen Berechnungen auf den importierten Daten durchgeführt werden können. Auch ist eine Markierung eines gezielten  Datensatzes unmöglich.
\paragraph{Lokalisierbarkeit}
Aus dem Ziel, die Eingabedaten im dreidimensionalen, kartesischen Raum darzustellen ergibt sich eine ganz logische Voraussetzung: Es sollte mindestens für jede der drei Dimensionen eine Eigenschaft der Daten existieren, die eine Positionierbarkeit möglich macht. Zwar ist es genauso möglich, die Daten auf einer Linie anzuordnen und somit nur eine Positionierungseigenschaft vorauszusetzen oder sich analog auf den zweidimensionalen Raum zu beschränken. Der daraus resultierende Informationsverlust muss aber in Kauf genommen werden.

Die Voraussetzungen an den Typ der für die Lokalisierung herangezogenen Eigenschaften sind nicht sehr streng. Zwar ist es zielführend, wenn es sich hier um kontinuierliche oder zumindest diskret ganzzahlige  Größen handelt. Ist dies nicht der Fall, so müssen diese lediglich zur Berechnung der Anzeigekoordinaten mit einer geeigneten Abbildungsvorschrift umgerechnet werden.
\begin{table*}[ht!]
	\centering
		\begin{tabular}{ | l | l |}
		\hline
			\emph{mittelbar geeignet}      & \emph{unmittelbar geeignet}       \\ \hline
		  IP [ABK] Adressen       & Entfernungsangaben         \\ \hline
      MAC [ABK] Adressen      & Ortsangaben (Länge/Breite) \\ \hline
      Zeichenketten allgemein & Zeitangaben \\
      \hline
		\end{tabular}
	\caption{Beispiele für unmittelbar und mittelbar geeignete Größen}
	\label{tab:mittelUnmittlGroessen}
\end{table*}
\paragraph{Weitere Eigenschaften}
Die Darstellung von Daten im dreidimensionalen Raum, lediglich basierend auf der Position und dem Namen, bietet noch keine hohe Anschaulichkeit. Um die in [Verweis, Visualisierungsmöglichkeiten] dargestellten Visualisierungen auch verwenden zu können, braucht es weitere Eigenschaften, die in optische Information umgewandelt werden kann.

Die Art der Daten die für solche zusätzliche Veranschaulichung verwendet kann, muss nicht genau spezifiziert werden. Trotzdem gibt es Typen, die sich für bestimmte Visualisierungsmöglichkeiten besser eignen. Als einfaches Bespiel seien hier Aufzählungsdatentypen genannt, die sich gerade zu anbieten, in Objekte in unterschiedlichen Farben darzustellen. Dabei können auch unterschiedliche Enumerationen gleichzeitig visualisiert werden, indem pro Eigenschaft eine Farbe verwendet wird, die je nach Wert der Eigenschaft in unterschiedlichen Helligkeiten dargestellt wird. Der Kreativität sind hier keine Grenzen gesetzt.
\subsubsection{Datenmodell}
\label{ch:Datenmodell}
Das im Rahmen dieser Arbeit entwickelte Datenmodell setzte den Grundstock für das später entworfene Framework und hat zum Ziel, durch generische Gestaltung in der Lage zu sein, unterschiedlichste Quelldaten ohne Anpassung speichern zu können.

Umgesetzt wurden diese Anforderungen durch die Trennung in eine Datensammlung und deren Daten auf der einen, und Eigenschaften auf der anderen Seite. 
\paragraph{Datensammlung mit Daten}
Wie in \ref{fig:DataModelOverview} dargestellt, besteht das wesentliche Datenmodell aus zwei Klassen.
\begin{description}
\begin{figure}[H]
	\centering
		\includegraphics[width=0.75\textwidth]{Bilder/DataModelOverview.png}
	\caption{Übersicht des Datenmodells}
	\label{fig:DataModelOverview}
\end{figure}
	\item[DataSet] Die Klasse DataSet kapselt die einzelnen Datensätze in Form einer Liste. Diese Klasse ist die zentrale Datenstruktur, die für alle weiteren Prozesse die notwendigen Informationen bereithält. Sie besteht im Wesentlichen aus zwei Bestandteilen. Das erste ist die angesprochene Liste der gespeicherten Daten. Weiterhin kann sie Eigenschaften erfassen, die nicht einem bestimmten Datum zu Eigen sind, sondern global für die gesamte Datensammlung gelten. Das benutzen dieser Eigenschaften ist aber fakultativ um eine hohe Flexibilität zu gewährleisten.
Die Typisierung der Eigenschaften wird weiter unten dargestellt.

  \item[Data] Die Klasse Data Kapselt ein einzelnes Datum. Wie bereits in \ref{ch:Eingabedaten} dargelegt, sind die notwendigen Bestandteile eines Datensatzes ein Bezeichner, der innerhalb einer Datensammlung eindeutig sein muss, sowie eine Positionsangabe. Diese ist mithilfe einer zusammengesetzten Eigenschaft festgehalten. Das Eigenschaftssystem wird weiter unten noch detailliert beschrieben.
  
\begin{figure}[H]
	\centering
		\includegraphics[width=0.5\textwidth]{Bilder/dataModelData.png}
	\caption{Aufbau der Klasse Data}
	\label{fig:dataModelData}
\end{figure}


Zusätzlich zu diesen beiden obligatorischen Angaben erfasst die Data-Klasse weiterhin drei Listen von Eigenschaften.
\begin{itemize}
	\item Einfache Eigenschaften
	\item Zusammengesetzte Eigenschaften
	\item Taxonomien
\end{itemize}
Die einfachen Eigenschaften sind in der Lage textuelle und Numerische Merkmale eines Datensatzes zu erfassen. Sie sind Grundlage die spätere Visualisierung. Die Zusammengesetzten Eigenschaften ermöglichen das Ablegen von vektoriellen Größen, wie zum Beispiel einer Blickrichtung, Geschwindigkeiten, oder Beschleunigungen usw. Auch ist es möglich mit ihrer Hilfe baumartig strukturierte Eigenschaften zu erfassen.

Die Taxonomien umfassen eine Liste möglicher Klassifikationen, die einem Datensatz zu Eigen sein können. Auch ihre Angabe ist nicht zwingend erforderlich.

Der Aufbau einer Data-Klasse kann in \ref{fig:dataModelData} nachvollzogen werden.
\end{description}
\paragraph{Eigenschaften}
\label{sec:Eigenschaften}
Die Eigenschaften der Datensammlung, wie auch die der Daten an sich, sollten so generisch aufgebaut sein, dass sie für möglichst viele unterschiedliche Anwendungsgebiete ohne Änderung und Anpassung übernommen werden können. 

Beim Entwurf fiel auf, dass die auftretenden Eigenschaften nach zwei Kriterien zerfallen. Auf der einen Seite kann nach Dimension der Eigenschaften unterschieden werden. So kann zum Beispiel gespeichert werden, ob die Einheit in einem Schlachtfeldsimulator feindlich, freundlich oder neutral ist. Weiterhin ist es wäre es möglich, eine Gewichtsangabe zu speichern. In beiden fällen handelt es sich um eine einfache, weil eindimensionale, Eigenschaft. 

Im Gegensatz gibt es zusammengesetzte Eigenschaften wie vektorielle Größen. In diesen Bereich fallen auch Gliederungsinformationen, oder Unterstellungsverhältnisse. Eine zusammengesetzte Eigenschaft besteht damit entweder aus einfachen, oder wiederum aus zusammengesetzten Eigenschaften.
Diese Unterscheidung führte im Entwurf zur Auswahl des Composite-Patterns (nach \cite{designpatterns}) für die Modellierung des Sachverhalts.

Das zweite Kriterium, in das die Informationen der Daten zerfallen, ist der Typ dieser. Um einen Kompromiss zwischen einem kompakten Datenmodell und einem breiten Spektrum unterstützter Typen zu gewährleisten, fiel die Entscheidung auf folgende Datentypen:
\begin{itemize}
	\item Boolean
	\item Char
	\item Date [ANM]
	\item Float
	\item Integer
	\item String
\end{itemize}
Um die grundlegenden Bedürfnisse zu stillen, hätte auch eine Auswahl eines Fließkommadatentyps, mit dem sich auch ganze Zahlen darstellen lassen, und ein Zeichenkettendatentyp, mit dem alle anderen Informationen gespeichert werden können, ausgereicht. Eine noch kleinere Teilmenge, die nur den String-Datentyp umfasst, wäre unter Ausnutzung von programmiersprachenspezifischen Typumwandlungen auch denkbar gewesen. Diese beiden Möglichkeiten wurden aber mit Hinblick auf die komfortablere Handhabung verworfen.
\begin{figure}[H]
	\centering
		\includegraphics[width=0.75\textwidth]{Bilder/dataModelProperties.png}
	\caption{Eigenschaftssystem im Datenmodell}
	\label{fig:dataModelProperties}
\end{figure}

Der resultierende Entwurf ist in \ref{fig:dataModelProperties} dargestellt. Er besteht aus der abstrakten Eigenschaft, den konkreten Implementierungen nach Datentypen und der Zusammengesetzten Eigenschaft.

\begin{description}
	\item[AbstractProperty] Die abstrakte Klasse dient als Muster für die konkreten Implementierungen. Sie wird über einen Bezeichner eindeutig identifiziert. Es bietet sich hier an, menschenlesbare Namen zu verwenden, die zugleich beschreibenden Charakter haben. Zusätzlich hat jede Eigenschaft einen Typ. Dieser ist bereits in der abstrakten Klasse implementiert, um zur Laufzeit ohne Kenntnis der genauen Implementierung den jeweiligen Typ der Eigenschaft abzufragen.
	
Der Satz an abstrakten Methoden bildet die notwendige Schnittstelle um den Wert einer Eigenschaft zu lesen und zu schreiben. Hier stellt sich die Frage, warum eine abstrakte Klasse und nicht etwa ein Interface gewählt wurde. Die Antwort ergibt sich aus der Möglichkeit die Typinformationen und den Bezeichner in der allgemeinen Eigenschaft vorhalten zu können. Das entlastet den Programmierer bei der Umsetzung der konkreten Implementierungen, da er sich darum nicht mehr kümmern muss.

Aus Sicht des Composite-Patterns stellt AbstractProperty die Component-Klasse dar.
\item[Typ-Property] Die Implementierungen der abstrakten Klasse tragen in der Umsetzung die Verantwortung, einen zum Typ passenden Wert zu speichern. Dieser wird in der Ausgestaltung der Manipulationsmethoden gesetzt und gelesen. Wo notwendig sind Typumwandlungen durchzuführen, bei unsinnigen Operationen (zum Beispiel das Umwandeln eines bool'schen  in ein Datum) sollten Exceptions geworfen werden.

Eine Typ-Property ist die im Composite-Pattern als Leaf bezeichnete Klasse.
\item[ContainerProperty] Die zusammengesetzte Eigenschaft verwaltet ihre zugehörigen Eigenschaften in einer Liste. Sie kann aus Typ-Property-Klassen bestehen, oder wiederum aus zusammengesetzten Eigenschaften. Aus diesem Grund enthält die Liste, die den Wert der ContainerProperty darstellt, nur AbstractProperty-Klassen. Darum stellt diese Klasse den Composite dar.
\end{description}
\paragraph{Erweiterbarkeit}
Das Datenmodell ist an der Stelle der Eigenschaften erweiterbar. Um einen neuen Typ einzuführen müssen vier Schritte durchgeführt werden: 

In der Enumeration der Typen ist der neue einzuführen. Weiterhin muss in der abstrakten Klasse die Zugriffs- und Manipulationsmethoden abstrakt definiert werden. Daraus folgt, dass bestehende Typen diese Methoden implementieren müssen. Macht eine Typumwandlung Sinn, dann kann diese umgesetzt werden. Meist können die Methoden jedoch auf das Werfen einer Exception reduziert werden.

Abschließend muss nun eine neue Typ-Property Klasse erstellt und implementiert werden, die von ihrem abstrakten Vorbild erbt. 
Durch diese vier Schritte hat man somit das Datenmodell um einen Typ erweitert.
\subsection{Übersicht über das Frontend des Frameworks}
\begin{figure}[ht!]
	\centering
		\includegraphics[width=0.75\textwidth]{Bilder/framework.png}
	\caption{Übersicht des Frameworks (Frontend/Backend)}
	\label{fig:framework}
\end{figure}

Das erstellte Framework besteht im Wesentlichen aus zwei Teilen. Auf der einen Seite stehen die für den Benutzer sichtbaren Klassen, an denen nicht notwendigerweise eine Anpassung vorgenommen werden muss, um ein lauffähiges Programm zu erstellen. Zu diesen Klassen gehört auf oberster Ebene die FusionVisForm. Diese ist die dem Benutzer angezeigte Programmoberfläche. Sie besteht aus einem Menü mit implementierter Funktion zum Auswählen von XML-Dateien und zum Schließen des Programms. 

Die Form enthält weiterhin zwei Panels, die es dem Benutzer ermöglichen, eine textuelle und eine visuelle Darstellung der Daten zu sehen. 
\begin{description}
	\item[ImporterPanel] Für die textuelle Sicht ist das ImporterPanel vorgesehen. Es bietet die Möglichkeit, die Daten zu nach bestimmten Eigenschaften zu filtern und die Daten mit ihren Eigenschaften in Textform anzuzeigen. Das Model, auf dem gearbeitet wird, ist das in \ref{ch:Datenmodell} beschriebene Datenmodell. Somit ist das ImporterPanel auch völlig unabhängig von dem genauen Inhalt der Daten, solange diese in das beschriebene Model überführt wurden. Dafür ist der Importer zuständig, der im nächsten Abschnitt beschrieben wird.

	\item[ViewerPanel]Das zweite Panel ist das ViewerPanel. Es ist verantwortlich für die dreidimensionale Anzeige der Daten. Dazu ist es notwendig, das vorhandene Datenmodell in die Struktur eines Szenenbaums zu überführen. Der Szenenbaum wird in [REF Kapitel 4 jme] beschrieben. Dieser Schritt wird vom Mapper bewerkstelligt, der im nächsten Abschnitt erklärt wird.

Der erstellte Szenenbaum kann nun von einem Viewer angezeigt werden. Dieser beinhaltet eine OpenGL-Anzeigefläche, die die dreidimensionale Darstellung übernimmt und es dem Benutzer erlaubt, sich in den visualisierten Daten zu bewegen, Datensätze mittels Mousepickings (siehe \ref{ch:mousepicking}) auszuwählen und diese somit im ImporterPanel zu inspizieren. Auch der umgekehrte Weg ist möglich, also das Auswählen eines Datums in der textuellen Ansicht, was eine Hervorhebung seiner Visualisierung im ViewerPanel zur Folge hat.
\end{description}

Zusammenfassen kann man zum Fronend des Frameworks sagen, dass die von den konkreten XML-Daten unabhängigen Funktionen bereits implementiert sind. Der Anwender muss lediglich festlegen, was schließlich wie dargestellt werden soll. Das Was ist der Prozess des Überführens von XML in das Datenmodell des Frameworks und wird im Importer festgeschrieben. Das Wie ist die Frage nach der Art und Weise, wie die Daten dreidimensional dargestellt werden sollen und wird im Mapper beantwortet.

\subsection{Übersicht über das Backend des Frameworks}
Das Backend besteht im Wesentlichen aus den zwei oben erwähnten Komponenten, Importer und Mapper. Im Folgenden sollen die Funktion der beiden erläutert und notwendige Schritte der Spezialisierung beschrieben werden.

Die Spezialisierung bezieht sich auf das Implementieren abstrakter Methoden, die in den beiden als abstrakt gekennzeichneten Klassen die eigentliche Funktion enthalten sollen.
\subsubsection{Importer}
Der Importer ist, wie bereits im letzten Abschnitt angemerkt, dafür verantwortlich, die Daten aus einer XML-Datei zu lesen. An die Struktur muss eine Voraussetzung gemacht werden, um den Import automatisiert durchführen zu können: Die Datensätze müssen als Elemente des Wurzelknotens in der XML-Dateien stehen. Ein Beispiel für eine XML-Datei, die diese Anforderung erfüllt ist in Listing \ref{code:xmlexample}.

Ist die Voraussetzung erfüllt, liest der Importer die XML-Datei aus und extrahiert die DOM-Knoten der Datenelemente. Die Wahl des DOM-Parsers für diese Aufgabe wird noch in [REF] genauer erläutert. 

\lstset{%
language=XML,
basicstyle={\ttfamily,\footnotesize},
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=2,
}%
\begin{lstlisting}[breaklines=true,frame=tlRB,captionpos=b,caption={Beispiel für eine wohlgeformte XML-Datei},label=code:xmlexample]
<Situation>
  <Units>
   <Unit>
      <Name>FriendlyTank1</Name>
      <Location>
        <Lat>52.796629714678467</Lat>
        <Lon>9.89990561649954</Lon>
        <LastModified>2009-02-20T10:25:36+01:00</LastModified>
      </Location>
    </Unit>
    <Unit>
      <Name>FriendlyTank2</Name>
      <Location>
        <Lat>52.794038961891268</Lat>
        <Lon>9.9011727699025922</Lon>
        <LastModified>2009-02-20T10:25:36+01:00</LastModified>
      </Location>
    </Unit>
  </Units>
</Situation>
\end{lstlisting}

Der Importer hält bereits notwendige Datenstrukturen vor. Zum einen sind dies zwei Membervariablen (\emph{id}, \emph{position}). Diese dienen dem Speichern der XML-Elementnamen, die den Wert für Position und Bezeichner eines Datums liefern. Ähnlich gibt es drei Listen, die die Elementnamen enthalten, die als einfache, zusammengesetzte Eigenschaften oder als Taxonomie extrahiert werden.

\paragraph{Spezialisierung}
\label{sec:ImporterSpezialisierung}
Zur  Spezialisierung eines Importers für ein bestimmtes Datenformat müssen zwei Schritte durchlaufen werden.  Als erstes sollten die in das Datenmodell als Eigenschaft von Daten zu übernehmenden XML-Elemente auf die oben angesprochenen Membervariablen und Listen verteilt werden. 

Als nächstes muss nun die Methode \emph{extractDataFormNode()} implementiert werden. Ihr wird ein Knoten des DOM-Dokumentbaums übergeben. Dieser zeigt auf ein Element, dass als Datum in das Datenmodell übernommen werden soll. Die Aufgabe der Funktion ist es nun nach den Vorstellungen des Anwenders ein Data-Objekt zu erzeugen, das die Eigenschaften enthält, die in den vorher spezifizierten Listen stehen.

\paragraph{Hilfsfunktionen}
\label{sec:ImporterHilfsfunktionen}
In der Input-Klasse sind bereits zwei Hilfsfunktionen implementiert, die dem Anwender die Arbeit beim erzeugen der Data-Objekte vereinfachen sollen. Die Methode \emph{parseDate()} dient dem Auslesen eines Datums aus einem String. Für die genauere Dokumentation sei hier auf das JavaDoc verwiesen.

Die Methode  \emph{extractSimpleProperty(Node, Type)} erzeugt eine einfache Eigenschaft (siehe \ref{sec:Eigenschaften}) eines angegebenen Typs aus einem DOM-Knoten. Um beispielsweise in Zeile 4 von Listing \ref{code:extractDataFromNode} eine Eigenschaft \emph{Name} als String zu extrahieren, muss die Hilfsfunktion lediglich mit der Node aufgerufen werden, die auf dieses Element zeigt und dem gewünschten Typen (hier: \emph{Type.TString}).


\lstset{%
language=Java,
showstringspaces=false,
keywordstyle=\color{red},
breaklines=true,
frame=single
commentstyle=\color{blue},
stringstyle=\color{green},
backgroundcolor=\color{white},
basicstyle={\ttfamily,\footnotesize},       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=2
}%
\begin{lstlisting}[breaklines=true,frame=tlRB,captionpos=b,caption={Beispielhafte Implementierung der \emph{extractDataFromNode()}-Methode}, ,label=code:extractDataFromNode]
  protected Data extractDataFromNode(Node unitNode) throws Exception {
    Data result = null;
    NodeList list = unitNode.getChildNodes();
    // Erster Durchlauf zum Finden des Bezeichners
    for (int i = 0; i < list.getLength(); i++) {
      if (list.item(i).getNodeType() != Node.ELEMENT_NODE)
        continue; // wenn kein Element, dann skip
      Node element = list.item(i);
      if (element.getNodeName().equals(id))
        result = new Data(element.getTextContent());
    }
    // Zweiter Durchlauf für das setzen der restlichen Eigenschaften
    for (int i = 0; i < list.getLength(); i++) {
      if (list.item(i).getNodeType() != Node.ELEMENT_NODE)
        continue; // wenn kein Element, dann skip
      Node element = list.item(i);
      // Position setzen
      if (element.getNodeName().equals(position))
        result
            .setPosition(extractContainerProperty(element,
                "Position"));
      else if (simplePropertyList.contains(element.getNodeName()))
        if (element.getNodeName().equals("IsPlatform"))
          result.addAbstractProperty(extractSimpleProperty(element,
              Type.TBool));
        else
          result.addAbstractProperty(extractSimpleProperty(element,
              Type.TString));
      else if (vectorPropertyList.contains(element.getNodeName()))
        result.addContainerProperty(extractContainerProperty(element,
            element.getNodeName()));
      else if (taxonomyList.contains(element.getNodeName()))
        result.addTaxonomie((extractSimpleProperty(element)));
      else ; // skip
    }
    return result;
  }
 \end{lstlisting}
%\paragraph{Anbindung an XML}
%\paragraph{Instanzieren des Datenmodells}
\subsubsection{Mapper}
Bereits im vorletzten Abschnitt wurde angesprochen, dass der Mapper dafür Sorge trägt, dass das Datenmodell in eine dreidimensionale Darstellung überführt wird. Da nicht für jedes Problem auch dieselbe Visualisierung zielführend ist, besteht hier die Möglichkeit zur Individualisierung.

Bei der individuellen Ausgestaltung sind zwei unterschiedliche Aspekte zu unterscheiden: Auf der einen Seite ist die Frage, wie die Daten an sich dargestellt werden, zum Beispiel in Bezug auf Form und Farbe, sowie das sonstige Erscheinungsbild. Auf der anderen Seite muss spezifiziert werden, in welcher Art und Weise die Dimensionen der Daten dargestellt werden.

Resultat des Mappingvorgangs soll ein Szenenbaum sein. Er ist die für die Engine lesbare Form des Datenmodells. Dieser Szenenbaum muss bei jeder Veränderung des Datenmodells aktualisiert werden. Als solche zählt zum Beispiel das Filtern von Daten nach bestimmten Eigenschaften, oder das Erstellen einer Sicht auf das Datenmodell.
\paragraph{Spezialisierung}
\label{sec:MapperSpezialisierung}
\paragraph{Hilfsfunktionen}
\label{sec:MapperHilfsfunktionen}

\subsection{Zusammenspiel der Komponenten}
\subsubsection{Visualisierungsprozess}
\subsubsection{Importer und Mapper}
\subsubsection{Viewer und Importer}
\subsubsection{Viewer und Mapper}

\section{Visualisierung einer militärischen Lage}
\label{ch:Prototyp}
%\section{Erweiterbarkeit und Individualisierbarkeit}


\section{Kernaspekte der Implementierung}
\subsection{Mapper}
\subsubsection{Streckung der Eingabedaten auf den Projektionsbereich}
\subsubsection{Entfernungsberechnung mithilfe der Haversine Formel}
\subsubsection{Informationsverlust durch Projektion eines Kugelabschnitts auf eine Ebene}
\subsection{Viewer}
\subsubsection{Mousepicking}
\label{ch:mousepicking}
\subsubsection{Bewegungskegel}


