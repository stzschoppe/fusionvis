\chapter{Verwendete Technologien}
\label{ch:technologien}
In diesem Kapitel werden die wichtigsten Technologien, die im Laufe der Arbeit verwendet werden, vorgestellt und erläutert.

\section{Java}
\label{sec:java}
Am Anfang der Arbeit stand die Wahl der Programmiersprache, die für die Implementierung verwendet werden sollte. Java in der Version 1.6 bot sich aus mehren Gründen an.

Auf der einen Seite sprach ein ganz pragmatischer Grund dafür: Da Java im Rahmen der Vorlesung über Objektorientierte Programmierung gelehrt wurde, entfiel die Einarbeitungszeit. Auf der anderen Seite gibt es aber weitere Gründe für die Wahl. An die prototypische Implementierung wurde die Anforderung der Plattformunabhängigkeit gestellt. Dies spricht für die Wahl einer Sprache, die auf einer virtuellen Maschine basiert. Im Gegensatz zu einem Java-Programm müsste ein in C++ geschriebenes auf einem anderen Rechner neu kompiliert werden. Dies erhöht den Installationsaufwand und ist keine echte Unabhängigkeit.

Unter den Sprachen, die auf einer Virtuellen Maschine basieren fällt aus Gründen der Plattformunabhängigkeit die .Net-Familie aus, da es sich hier um Microsoft- und somit betriebssystemspezifische Sprachen handelt. Weitere Gründe für die Wahl von Java waren existierende Klassenbibliotheken für die Verwendung von XML (siehe \ref{ch:xml}) und die Arbeit mit OpenGL als Programmierschnittstelle für die dreidimensional Visualisierung.

Ein Nachteil von Java ist die Umsetzung von GUI-Elementen. Zwar gibt es mit Swing und SWT leistungsfähige Bibliotheken, aber das Layout der grafischen Benutzeroberfläche ansprechend zu gestalten, stellt sich damit als schwierig heraus. Für die Umsetzung der grafischen Benutzeroberfläche wurde Swing gewählt, da es Bestandteil der mit Java ausgelieferten Klassenbibliothek ist

Weiterhin ist die Verwendung von Java für die Arbeit mit 3D-Grafik umstritten (siehe \cite{killer}). Ein großer Kritikpunkt ist dabei der Geschwindigkeitsverlust, der sich aus dem Interpretieren des Programms durch die Virtuelle Maschine ergibt. Wie stark dieser ins Gewicht fällt, ist umstritten. Da Geschwindigkeit für diese Arbeit aber nicht Ausschlaggebend ist, kann dieser Kritikpunkt vernachlässigt werden.
\section{XML}
\label{ch:xml}
Die Daten für das Testen der prototypischen Entwicklung stammen von einem Gefechtssimulator. Sie sind im XML-Format abgespeichert. Um mit diesen Daten in Java arbeiten zu können, müssen sie in Java-Klassen überführt werden. An dieser Stelle kamen zwei Möglichkeiten in Frage: Auf der einen Seite hätte nur die prototypische Implementierung, die mit den Daten arbeitet, diese eingelesen. Auf der anderen Seite konnte die Funktionalität, aus XML-Dateien zu laden, auch in das entwickelte Framework integriert werden.

Weil sich XML für einen plattform- und implementierungsunabhängigen Datenaustausch eignet und heute zu diesem Zweck ein Quasistandart ist (\cite{xml}), fiel die Entscheidung, das Laden von Daten im XML-Format im Framework zu implementieren. Die gewählte Programmiersprache eignete sich für diesen Zweck besonders gut, da bereits fertige Parser-Bibliotheken mitgeliefert werden.

\subsection{SAX-Parser}
\label{sec:SAXParser}
Hier standen DOM und SAX zur Auswahl. Beide haben Vor- und Nachteile. Welche Implementierung gewählt wird, hängt vom zu lösenden Problem ab. Wird mit großen Datenmengen gearbeitet und müssen diese oft neu geladen werden, ist SAX im Vorteil, weil es sich dabei um eine sehr performante Umsetzung handelt. Ein großer Nachteil ist die eingeschränkte Traversierbarkeit der Daten. Das hängt mit der Arbeitsweise des Parsers zusammen. Er arbeitet ereignisgesteuert. Das bedeutet, die XML-Datei wird sequentiell gelesen. Wird beispielsweise ein Element gefunden, wird eine Methode zur Verarbeitung von Elementen aufgerufen. Somit kann bei der Verarbeitung kein Rückschluss auf die Position eines Elements in der XML-Datei geschlossen werden. Genauso wenig kann auf Vorgänger, Nachfolger unter Unterelemente explizit zugegriffen werden.

\subsection{DOM-Parser}
\label{sec:DOMParser}
Der große Vorteil des DOM-Parsers ist eben die bei SAX nicht vorhandene Traversierbarkeit. Der Parser erzeugt beim Einlesen der XML-Datei einen Baum. Für jedes strukturelle Element der Daten wird ein Knoten erzeugt. Ein XML-Element ist ein Bespiel für einen solchen Knoten, aber auch ein Attribut. Auf diese Art und Weise ist es zum einen möglich, sich komfortabel durch die Daten zu bewegen. Weiterhin ist es so möglich, das Lesen von XML-Dateien in das erstellte Framework zu integrieren und für jede Implementierung mit lediglich geringem Implementierungsaufwand eine Leseroutine umzusetzen. Das Framework ist dann in der Verantwortung die Elemente zu extrahieren, die einen Datensatz darstellen. Der Anwender des Frameworks bekommt dann die Knoten der Datensätze und liest eigenständig die von ihm benötigten Informationen aus. Aus diesem Grund wurde DOM für diese Arbeit ausgewählt.

Die Tatsache, dass DOM nicht so sehr für große Datenmengen geeignet ist, weil das Erzeugen der Baumstruktur vor allem speicherplatzintensiv ist. Dieser Nachteil wird aber zum Wohle des einfacheren Umgangs in Kauf genommen.

\section{jMonkeyEngine}
\label{sec:jme}
Die in Abschnitt \ref{sec:java} beschriebene Anforderung, einen plattformunabhängigen Prototyp zu entwickeln, machte die Abwägung zwischen DirectX von Microsoft und der Opensource-Alternative OpenGL als 3D-Grafikschnittstelle überflüssig. Nur letztere bot eine überzeugende Möglichkeit, auf einem nicht-Windows System zu funktionieren.

Nachdem dieser Entschluss feststand, musste eine Klassenbibliothek gesucht werden, die den Umgang mit OpenGL vereinfacht und im Zeitrahmen dieser Arbeit die Entwicklung eines funktionsfähigen Prototyps ermöglicht. Die Wahl fiel dabei nach erster Recherche auf die sogenannte JMonkeyEngine (JME) in der Version 2. Der entscheidende Vorteil dieser Klassenbibliothek war die sehr kurze Einarbeitungszeit. Diese wurde vor allem dadurch begünstigt wurde, dass für erste Testprogramme sehr wenig eigener Quellcode geschrieben werden musste.

Ein weiterer Vorteil der Engine war die Art und Weise, wie Zeichnen der anzuzeigenden Objekte organisiert ist. Die Klassenbibliothek bedient sich eines Baums, in dem die Objekte gespeichert werden, der sogenannte Szenenbaum. Dieser und andere Eigenarten sollen im Folgenden kurz Skizziert werden.

\subsection{Szenenbaum}
\label{sec:Szenenbaum}

Diese Struktur dient zur Speicherung und Organisierung von Objekten, die grafisch dargestellt werden sollen. Auf der einen Seite kann der Baum aus Knoten der \emph{Node}-Klasse bestehen. Diese dienen der Strukturierung und werden nicht angezeigt. Auf der anderen Seite können Grafikobjekte in ihm gespeichert werden. Dies sind Instanzen von Klassen, die von der Klasse \emph{Geometry} abgeleitet wurden. Welche Grundformen JME bereits mitliefert, ist in einem der folgenden Abschnitte beschrieben. Neben dreidimensionalen Objekten können aber auch Lichtquellen und die Kamera an den Szenenbaum angehängt werden.

Der Vorteil des Szenenbaums besteht darin, dass sich Änderungen auf einen Knoten automatisch auch auf seine Kinder auswirken. Im, in dieser Arbeit entwickelten, Visualisierungsprototypen sollen Kugeln die Datensätze (Kampfpanzer) darstellen. Von ihrem Zentrum geht ein Kegel aus, der die Reichweite der Panzer symbolisiert. Der genaue Hintergrund ist in den  Abschnitten \ref{sec:TheorieBewegungskegel}, \ref{sec:Bewegungskegel} und \ref{ch:bewegungskegel} erläutert. Soll nun ein Datensatz ausgeblendet werden, weil er einem gesuchten Kriterium nicht entspricht könnte man trivialer Weise den Knoten, der die Kugel enthält, und den Knoten, der den Kegel darstellt, ausblenden. 

Durch die Funktionsweise des Szenenbaums ist es aber einfacher, die beiden Objekte unter einem Knoten zu vereinigen, der den Namen des Objekts enthält. So muss nur dieser -- nicht sichtbare -- Knoten ausgeblendet werden. Kreis und Kugel werden automatisch nicht mehr mit angezeigt. Weitere Änderungen, die sich auf die Kinder auswirken sind zum Beispiel Positionsänderungen, Drehungen im Raum und Änderung von sogenannten \emph{RenderStates}. Diese kapseln Zustände, wie die Textur (Oberfläche) eines Objekts oder seine Durchsichtigkeit.

\subsection{Kamera}
\label{sec:Kamera}
Eine Kamera, in JME als \emph{Camera}-Klasse umgesetzt, steht für den Blickpunkt des Beobachters. Was von der Kamera gesehen wird, kann der Benutzer auf dem Bildschirm dargestellt erkennen. Um festzulegen, was in das Blickfeld der Kamera fällt, muss diese initialisiert werden. Auf der einen Seite müssen Position und Blickrichtung festgelegt werden. Auf der anderen Seite muss der von der Kamera betrachtete Raum spezifiziert werden. Dieser ist eine Pyramide mit Rechteckiger Grundseite. 

Zur genauen Definition des Sichtfeldes ist das Verhältnis von Breite und Höhe des Bildschirms wichtig, um keine ungewollten Verzerrungen zu erhalten. Weiterhin muss die  Höhe und der Winkel, mit dem die Pyramide aufgespannt wird, angegeben werden. Der Betrachter steht dabei an der Spitze der Pyramide und schaut auf die Grundseite. Der Winkel stellt die Sichtfeldbreite dar, die Höhe steht für sie Sichtweite.

\subsection{Grafische Objekte}
\label{sec:GrafischeObjekte}
JME stellt bereits einige fertige geometrische Objekte in Form von Klassen bereit. Diese müssen im Bedarfsfall nur noch instanziiert werden. Auf der einen Seite gehören zu ihnen die zweidimensionale Scheibe, ein Viereck und ein Sechseck. Auf der anderen Seite gehören zu den dreidimensionalen Grundformen der Quader und sein an den Ecken abgerundetes Pendant, Kegel, Zylinder, Pyramide (mit viereckiger Grundfläche), Oktaeder und Ikosaeder. Weiterhin die Kugel, die Halbkugel, die Kapsel (wie sie von Medikamenten bekannt ist), ein dreidimensionaler Pfeil und ein aus drei Pfeilen gebildetes Achsenkreuz. Schlussendlich fehlen auch nicht die in der dreidimensionalen Computergrafik so beliebten Objekte Teekanne und Torus. Für Bilder und Beschreibungen sei auf \cite{jme} verwiesen.

Weitere Objekte können durch Kombination aus den Grundformen, durch explizite Definition von Polygonen oder durch das Laden fertiger Modelle in JME verwendet werden.

\subsubsection{Lageveränderung}
\label{sec:Lageveraenderung}
Nachdem ein Objekt erzeugt wurde ist es meist notwendig, ihm einen Ort im dreidimensionalen Raum zuzuweisen. Manchmal ist es auch notwendig, ein Objekt zu drehen. Wichtig ist an dieser Stelle, dass beim Instanziieren eines Objekts keine Informationen über Position und Drehung mitgegeben werden können.

\paragraph{Positionierung}
\label{sec:Positionierung}
Meist kann im Konstruktor eine Koordinate übergeben werden. Tut man dies, erschein das Objekt auch an der gewünschten Stelle. Problematisch ist aber, dass dadurch nicht die Position verändert wurde, sondern der Mittelpunkt des Objekts. Dieser liegt nach wie vor auf dem Koordinatenursprung. Hier gibt es einen Konflikt zwischen den lokalen Koordinaten eines Objekts und den Weltkoordinaten. Aus diesem Grund sollte der Mittelpunkt eines Objekts immer bei (0, 0, 0) belassen werden, wenn man nicht explizit einen anderen Mittelpunkt benötigt.

Um ein Objekt richtig im Raum zu platzieren, wird mit Hilfe der Methode \emph{setLocalTranslation()} die gewünschte neue Koordinate übergeben. Als Parameter der Methode dient ein dreidimensionaler Vektor.


\paragraph{Drehung}
\label{sec:Drehung}
Drehungen von Objekten im dreidimensionalen Raum sind rechenaufwendige Angelegenheiten. JME übernimmt diese Rechnungen, indem durch Angabe der der gewünschten Drehwinkel als Vektor (x, y, z) ein Quaternion erzeugt wird. Die Werte werden in Bogenmaß angegeben und beziehen sich auf Drehungen um die jeweiligen Achsen. Für die Bedeutung eines Quaternions sei auf [CITE] verwiesen.

Mit dem erstellten Quaternion kann die Methode \emph{setLocalRotation()} des zu drehenden Objekts aufgerufen werden.


\subsubsection{Oberflächengestaltung}
\label{sec:Oberflaechengestaltung}
Die Oberfläche von Objekten kann in vielerlei Art und Weise angepasst werden. Zwei dieser Möglichkeiten sind im Folgenden kurz vorgestellt.

\paragraph{Texturen}
\label{sec:Texturen}
Texturen stellen die Oberfläche von Objekten dar. Notwendig wird dies zum Beispiel, wenn eine Kugel in einer bestimmten Farbe dargestellt werden soll. Der triviale Ansatz, eine gewünschte Farbe zuzuweisen, scheitert. Diese Farbe ist nur ohne Einfluss von Lichtquellen sichtbar. Ohne den Einfluss dieser sind aber keinerlei Konturen zu erkennen und die räumliche Vorstellung eines Gegenstands geht verloren.

Texturen sind der Ausweg aus diesem Problem. Um eine Kugel rot zu färben, muss lediglich eine Grafikdatei, zum Beispiel eine PNG erstellt werden, die in dieser Farbe ausgefüllt ist. Die Größe kann auf ein Minimum (1x1 Pixel) beschränkt werden. Aus der Grafik kann ein \emph{Texture}-Objekt mit Hilfe eines \emph{TextureManagers} erstellt werden. Diese kann nach der Umwandlung in eine \emph{RenderState}-Instanz der Kugel zugewiesen werden. Diese ist daraufhin rot und als Kugel zu erkennen, im Gegensatz zum trivialen Ansatz.

\paragraph{Transparenz}
\label{sec:Transparenz}
Das Erzeugen durchsichtiger Objekte funktioniert ähnlich wie das oben beschriebene Anlegen einer Textur. Nur bedient man sich hier nicht einer Textur zum Erzeugen einer \emph{RenderState}-Instanz, die dem Objekt zugewiesen wird. Das Mittel der Wahl ist ein \emph{MaterialState}- und ein \emph{BlendingState}-Objekt. Bei der Erstellung der \emph{MaterialState}-Instanz wird unter anderem die Durchsichtigkeit bzw. die Solidität übergeben. Der Wert darf sich im Intervall [0, 1] bewegen. Null bedeutet, dass das Objekt unsichtbar ist, eins hingegen, dass es vollkommen undurchsichtig dargestellt wird.

\subsection{Licht}
\label{sec:Licht}
JME unterscheidet in Lichtarten und Lichtquellen. Beide Kategorien sollen hier kurz dargestellt werden.

\subsubsection{Lichtquellen}
\label{sec:Lichtquellen}

Es gibt drei Arten von Lichtquellen. Die erste Art ist die punktförmige Lichtquelle (\emph{PointLight}). Sie besitzt eine Position, von der sich das Licht in alle Richtungen ausbreitet. Die Intensität nimmt standardmäßig mit der Entfernung von der Lichtquelle ab. Weiterhin gibt es das gerichtete Licht (\emph{DirectionalLight}). Es leuchtet unendlich weit und hat keine Position, sondern nur einen Vektor, der angibt, in welche Richtung die Lichtstrahlen fallen. Vergleichbar ist diese Art der Lichtquelle mit der Sonne von der Erde aus. Zwar leuchtet die Sonne nicht unendlich weit, doch für die auf der Erde auftretenden Entfernungen im Verhältnis zur Entfernung zur Sonne kann dieser Fakt vernachlässigt werden. Die dritte Lichtquelle ist ein Lichtkegel (\emph{SpotLight}). Wie der Name es andeutet, ist dies ein Kegel, der alles beleuchtet, was sich in ihm befindet. Seine Leuchtkraft nimmt standardmäßig ebenso ab wie bei einer punktförmigen Lichtquelle.

\subsubsection{Lichtanteile}
\label{sec:Lichtanteile}

Das von den oben beschriebenen Lichtquellen ausgehende Licht besitzt drei Anteile, die vor allem im Hinblick auf ihre Farbe verändert werden können. Zuerst ist da das Raumlicht (\emph{Ambient Light}), das angibt in welcher Intensität und Farbe die Bereiche dargestellt werden sollen, die weder direkt noch indirekt beschienen werden (zum Beispiel Schlagschatten). Als Nächstes gibt es das nichtgerichtete Licht. Es handelt sich hierbei um die diffuse Lichteinstrahlung. Der letzte Lichtanteil ist das reflektierte Licht (\emph{Specular Light}). Dies ist die reflektierte Lichteinstrahlung. Je intensiver diese Art ausgeprägt ist, umso spiegelnder erscheinen Oberflächen.



\section{Google Code}
Bei der Entwicklung des praktischen Anteils dieser Arbeit bestand die Notwendigkeit, die erstellten Daten sicher abzulegen. Dafür eignet sich unter anderem die Arbeit auf einem Terminal-Server, wir er von der Universität der Bundeswehr angeboten wird. Dies ermöglicht, von unterschiedlichen Orten und an unterschiedlichen Rechnern zu arbeiten. Nachteil dieser Lösung ist jedoch, dass ein Speichern unterschiedlicher Versionen des erstellten Programms und auch dieser Arbeit nur schwer möglich ist.

Aus diesem Grund wurde für das im Rahmen dieser Arbeit erstellte Programm, aber auch für die schriftliche Ausarbeitung, ein Versionierungssystem verwendet. Aus der Lehre bereits bekannt war Subversion. Es wurde auch hier wegen der nicht mehr notwendigen Einarbeitung gewählt. 

Google stellt auf seinem Portal GoogleCode die Möglichkeit bereit, eine Projekt mit Hilfe von Subversion zu versionieren. Dieser sogenannte \emph{Project Hosting Service} hat zudem noch weitere Vorteile als nur eine komfortable Datensicherung: Der Projektstand kann online dokumentiert werden. Somit wird es möglich, den Betreuer dieser Arbeit auf dem neusten Stand zu halten. Er kann über das Abonnieren eines RSS-Feeds jederzeit Änderungen Nachverfolgen. Weiterhin bietet Google ein Wiki an, was die Vorstellung und die Dokumentation des Programms ermöglicht. Zusätzlich gibt es eine Downloadverwaltung in der Testversionen Screenshots und ähnliches zur Verfügung gestellt werden können.

Wie oben angesprochen, wurde nicht nur der praktische Teil der Arbeit, also der Quellcode, über das Versionierungssystem gesichert. Auch die schriftliche Ausarbeitung in Form des Rohzustands (\TeX-Dateien) und des fertigen PDF-Kompilats wurde auf im Googleprojekt gespeichert.

Zusammenfassend sind die Vorteile des oben geschilderten Vorgehens, dass der Quellcode und die schriftliche Ausarbeitung zuverlässig gesichert werden konnten.  Der Zugriff auf diese war ortsunabhängig über das Internet möglich. Mit Hilfe der Versionierung konnte nach Experimenten auf stabile Versionen zurückgegriffen werden. Durch RSS-Feeds war es dem Betreuer jederzeit möglich, den aktuellen Stand der Arbeit zu betrachten und die im Downloadbereich befindliche Version zu testen.
