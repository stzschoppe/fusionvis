\chapter{Verwendete Technologien}
\label{ch:technologien}
In diesem Kapitel werden die wichtigsten Technologien, die im Laufe der Arbeit verwendet werden, vorgestellt und erläutert.

\section{Java}
\label{sec:java}
Am Anfang der Arbeit stand die Wahl der Programmiersprache, die für die Implementierung verwendet werden sollte. Java in der Version 1.6 bot sich aus mehren Gründen an.

Auf der einen Seite sprach ein ganz pragmatischer Grund dafür: Da Java im Rahmen der Vorlesung über Objektorientierte Programmierung gelehrt wurde, entfiel die Einarbeitungszeit. Auf der anderen Seite gibt es aber weitere Gründe für die Wahl. An die prototypische Implementierung wurde die Anforderung der Plattformunabhängigkeit gestellt. Dies spricht für die Wahl einer Sprache, die auf einer virtuellen Maschine basiert. Im Gegensatz zu einem Java-Programm müsste ein in C++ geschriebenes auf einem anderen Rechner neu kompiliert werden. Dies erhöht den Installationsaufwand und ist keine echte Unabhängigkeit.

Unter den Sprachen, die auf einer Virtuellen Maschine basieren, fällt aus Gründen der Plattformunabhängigkeit die .Net-Familie aus, da es sich hier um Microsoft- und somit betriebssystemspezifische Sprachen handelt. Weitere Gründe für die Wahl von Java waren existierende Klassenbibliotheken für die Verwendung von \gls{xml} (siehe \ref{ch:xml}) und die Arbeit mit \gls{opengl} als Programmierschnittstelle für die dreidimensional Visualisierung.

Ein Nachteil von Java ist die Umsetzung von \gls{gui}-Elementen. Es gibt zwar mit Swing und \gls{swt} leistungsfähige Bibliotheken. Das Layout der grafischen Benutzeroberfläche ansprechend zu gestalten, stellt sich damit jedoch als schwierig heraus. Für die Umsetzung der grafischen Benutzeroberfläche wurde Swing gewählt, da es Bestandteil der mit Java ausgelieferten Klassenbibliothek ist.

Weiterhin ist die Verwendung von Java für die Arbeit mit 3D-Grafik umstritten (siehe \cite{killer}). Ein großer Kritikpunkt ist dabei der Geschwindigkeitsverlust, der sich aus dem Interpretieren des Programms durch die Virtuelle Maschine ergibt. Wie stark dieser ins Gewicht fällt, ist fraglich. Da Geschwindigkeit für diese Arbeit aber nicht ausschlaggebend ist, kann dieser Kritikpunkt vernachlässigt werden.
\section{XML}
\label{ch:xml}
Die Daten für das Testen der prototypischen Entwicklung stammen von einem Gefechtssimulator. Sie sind im \gls{xml}-Format abgespeichert. Um mit diesen Daten in Java arbeiten zu können, müssen sie in Java-Klassen überführt werden. An dieser Stelle kamen zwei Möglichkeiten in Frage: Auf der einen Seite hätte nur die prototypische Implementierung, die mit den Daten arbeitet, das Einlesen dieser implementieren können. Auf der anderen Seite ist die Funktionalität, aus \gls{xml}-Dateien zu laden, auch in das entwickelte Framework implementierbar.

Weil sich \gls{xml} für einen plattform- und implementierungsunabhängigen Datenaustausch eignet und heute zu diesem Zweck ein Quasistandart ist (\cite{xml}), fiel die Entscheidung, das Laden von Daten im \gls{xml}-Format im Framework zu implementieren. Die gewählte Programmiersprache eignete sich für diesen Zweck besonders gut, da bereits fertige Parser-Bibliotheken mitgeliefert werden.

\subsection{SAX-Parser}
\label{sec:SAXParser}
An dieser Stelle standen \gls{dom} und \gls{sax} zur Auswahl. Beide haben Vor- und Nachteile. Welche Implementierung gewählt wird, hängt von dem zu lösenden Problem ab. Wird mit großen Datenmengen gearbeitet und müssen diese oft neu geladen werden, ist \gls{sax} im Vorteil, weil es sich dabei um eine sehr performante Umsetzung handelt. Ein großer Nachteil ist die eingeschränkte Traversierbarkeit der Daten. Das hängt mit der Arbeitsweise des Parsers zusammen, da er nämlich ereignisgesteuert arbeitet. Das bedeutet, die \gls{xml}-Datei wird sequentiell gelesen. Wird beispielsweise ein Element gefunden, wird eine Methode zur Verarbeitung von Elementen aufgerufen. Somit kann bei der Verarbeitung kein Rückschluss auf die Position eines Elements in der \gls{xml}-Datei geschlossen werden. Genauso wenig kann auf Vorgänger, Nachfolger und Unterelemente explizit zugegriffen werden.

\subsection{DOM-Parser}
\label{sec:DOMParser}
Der große Vorteil des \gls{dom}-Parsers ist eben die bei \gls{sax} nicht vorhandene Traversierbarkeit. Der Parser erzeugt beim Einlesen der \gls{xml}-Datei einen Baum. Für jedes strukturelle Element der Daten wird ein Knoten erzeugt. Ein \gls{xml}-Element ist ein Bespiel für einen solchen Knoten, aber auch ein Attribut. Auf diese Art und Weise ist es zum Einen möglich, sich komfortabel durch die Daten zu bewegen. Weiterhin kann man so das Lesen von \gls{xml}-Dateien in das erstellte Framework zu integrieren und für jede Implementierung mit lediglich geringem Implementierungsaufwand eine Leseroutine umzusetzen. Das Framework ist dann in der Verantwortung die Elemente zu extrahieren, die einen Datensatz darstellen. Der Anwender des Frameworks bekommt dann die Knoten der Datensätze und liest eigenständig die von ihm benötigten Informationen aus. Aus diesem Grund wurde \gls{dom} für diese Arbeit ausgewählt.

\gls{dom} ist nicht so sehr für große Datenmengen geeignet, weil das Erzeugen der Baumstruktur vor allem speicherplatzintensiv ist. Dieser Nachteil wird aber zum Wohle des einfacheren Umgangs in Kauf genommen.

\section{jMonkeyEngine}
\label{sec:jme}
Die in Abschnitt \ref{sec:java} beschriebene Anforderung, einen plattformunabhängigen Prototyp zu entwickeln, machte die Abwägung zwischen DirectX von Microsoft und der Opensource-Alternative \gls{opengl} als 3D-Grafikschnittstelle überflüssig. Nur letztere bot eine überzeugende Möglichkeit, auf einem nicht-Windows System zu funktionieren.

Nachdem dieser Entschluss feststand, musste eine Klassenbibliothek gesucht werden, die den Umgang mit \gls{opengl} vereinfacht und im Zeitrahmen dieser Arbeit die Entwicklung eines funktionsfähigen Prototyps ermöglicht. Die Wahl fiel dabei nach erster Recherche auf die sogenannte \gls{jme} in der Version 2. Der entscheidende Vorteil dieser Klassenbibliothek war die sehr kurze Einarbeitungszeit. Diese wurde vor allem dadurch begünstigt, dass für erste Testprogramme sehr wenig eigener Quellcode geschrieben werden muss.

Ein weiterer Vorteil der Engine war die Art und Weise, wie Zeichnen der anzuzeigenden Objekte organisiert ist. Die Klassenbibliothek bedient sich eines Baums, in dem die Objekte gespeichert werden, der sogenannte Szenenbaum. Dieser und andere Eigenarten sollen im Folgenden kurz Skizziert werden.

\subsection{Szenenbaum}
\label{sec:Szenenbaum}

Diese Struktur dient zur Speicherung und Organisation von Objekten, die grafisch dargestellt werden sollen. Auf der einen Seite kann der Baum aus Knoten der \emph{Node}-Klasse bestehen. Diese dienen der Strukturierung und werden nicht angezeigt. Auf der anderen Seite können Grafikobjekte in ihm gespeichert werden. Dies sind Instanzen von Klassen, die von der Klasse \emph{Geometry} abgeleitet wurden. Welche Grundformen \gls{jme} bereits mitliefert, ist in Abschnitt \ref{sec:GrafischeObjekte} beschrieben. Neben dreidimensionalen Objekten können aber auch Lichtquellen und die Kamera an den Szenenbaum angehängt werden.

Der Vorteil des Szenenbaums besteht darin, dass sich Änderungen auf einen Knoten automatisch auch auf seine Kinder auswirken. Im, in dieser Arbeit entwickelten, Visualisierungsprototypen sollen Kugeln die Datensätze (Kampfpanzer) darstellen. Von ihrem Zentrum geht ein Kegel aus, der die Reichweite der Panzer symbolisiert. Der genaue Hintergrund ist in den  Abschnitten \ref{sec:TheorieBewegungskegel}, \ref{sec:Bewegungskegel} und \ref{ch:bewegungskegel} erläutert. Soll nun ein Datensatz ausgeblendet werden, weil er einem gesuchten Kriterium nicht entspricht, könnte man trivialer Weise den Knoten, der die Kugel enthält, und den Knoten, der den Kegel darstellt, ausblenden. 

Durch die Funktionsweise des Szenenbaums ist es aber einfacher, die beiden Objekte unter einem Knoten zu vereinigen, der den Namen des Objekts enthält. So muss nur dieser -- nicht sichtbare -- Knoten ausgeblendet werden. Kreis und Kugel werden automatisch nicht mehr mit angezeigt. Weitere Änderungen, die sich auf die Kinder auswirken, sind zum Beispiel Positionsänderungen, Drehungen im Raum und Änderung von sogenannten \emph{RenderStates}. Diese kapseln Zustände, wie die Textur (Oberfläche) eines Objekts oder seine Durchsichtigkeit.

\subsection{Kamera}
\label{sec:Kamera}
Eine Kamera, in \gls{jme} als \emph{Camera}-Klasse umgesetzt, steht für den Blickpunkt des Beobachters. Was von der Kamera gesehen wird, kann der Benutzer auf dem Bildschirm dargestellt erkennen. Um festzulegen, was in das Blickfeld der Kamera fällt, muss diese initialisiert werden. Zum Einen müssen Position und Blickrichtung festgelegt werden. Weiterhin muss der von der Kamera betrachtete Raum spezifiziert werden. Dieser ist eine Pyramide mit rechteckiger Grundseite. 

Zur genauen Definition des Sichtfeldes ist das Verhältnis von Breite und Höhe des Bildschirms wichtig, um keine ungewollten Verzerrungen zu erhalten. Weiterhin muss die  Höhe und der Winkel, mit dem die Pyramide aufgespannt wird, angegeben werden. Der Betrachter steht dabei an der Spitze der Pyramide und schaut auf die Grundseite. Der Winkel stellt die Sichtfeldbreite dar, die Höhe steht für sie Sichtweite.

\subsection{Grafische Objekte}
\label{sec:GrafischeObjekte}
\gls{jme} stellt bereits einige fertige geometrische Objekte in Form von Klassen bereit. Diese müssen im Bedarfsfall nur noch instanziiert werden. Auf der einen Seite gehören zu ihnen die zweidimensionale Scheibe, ein Viereck und ein Sechseck. Auf der anderen Seite gehören zu den dreidimensionalen Grundformen der Quader und sein an den Ecken abgerundetes Pendant, Kegel, Zylinder, Pyramide (mit viereckiger Grundfläche), Oktaeder und Ikosaeder. Weiterhin die Kugel, die Halbkugel, die Kapsel (wie sie von Medikamenten bekannt ist), ein dreidimensionaler Pfeil und ein aus drei Pfeilen gebildetes Achsenkreuz. Schlussendlich fehlen auch nicht die in der dreidimensionalen Computergrafik so beliebten Objekte Teekanne und Torus. Für Bilder und Beschreibungen sei auf \cite{jme} verwiesen.

Weitere Objekte können durch Kombination aus den Grundformen, durch explizite Definition von Polygonen oder durch das Laden fertiger Modelle in \gls{jme} verwendet werden.

\subsubsection{Lageveränderung}
\label{sec:Lageveraenderung}
Nachdem ein Objekt erzeugt wurde, ist es meist nötig, ihm einen Ort im dreidimensionalen Raum zuzuweisen. Manchmal ist es auch notwendig, ein Objekt zu drehen. Wichtig ist an dieser Stelle, dass beim Instanziieren eines Objekts keine Informationen über Position und Drehung mitgegeben werden können.

\paragraph{Positionierung}
\label{sec:Positionierung}
Meist kann im Konstruktor eine Koordinate übergeben werden. Tut man dies, erschein das Objekt auch an der gewünschten Stelle. Problematisch ist aber, dass dadurch nicht die Position verändert wurde, sondern der Mittelpunkt des Objekts. Dieser liegt nach wie vor auf dem Koordinatenursprung. Hier gibt es einen Konflikt zwischen den lokalen Koordinaten eines Objekts und den Weltkoordinaten. Aus diesem Grund sollte der Mittelpunkt eines Objekts immer bei (0, 0, 0) belassen werden, wenn man nicht explizit einen anderen Mittelpunkt benötigt.

Um ein Objekt richtig im Raum zu platzieren, wird mit Hilfe der Methode \emph{setLocalTranslation()} die gewünschte neue Koordinate übergeben. Als Parameter der Methode dient ein dreidimensionaler Vektor.


\paragraph{Drehung}
\label{sec:Drehung}
Drehungen von Objekten im dreidimensionalen Raum sind rechenaufwendige Angelegenheiten. \gls{jme} übernimmt diese Rechnungen, indem durch Angabe der gewünschten Drehwinkel als Vektor (x, y, z) ein Quaternion erzeugt wird. Die Werte werden in Bogenmaß angegeben und beziehen sich auf Drehungen um die jeweiligen Achsen. Für die Bedeutung eines Quaternions in diesem Zusammenhang sei auf \cite{quaternion-shoemake1985} verwiesen.

Mit dem erstellten Quaternion kann die Methode \emph{setLocalRotation()} des zu drehenden Objekts aufgerufen werden.


\subsubsection{Oberflächengestaltung}
\label{sec:Oberflaechengestaltung}
Die Oberfläche von Objekten kann in vielerlei Art und Weise angepasst werden. Zwei dieser Möglichkeiten sind im Folgenden kurz vorgestellt.

\paragraph{Texturen}
\label{sec:Texturen}
Texturen stellen die Oberfläche von Objekten dar. Notwendig wird dies zum Beispiel, wenn eine Kugel in einer bestimmten Farbe dargestellt werden soll. Der triviale Ansatz, eine gewünschte Farbe zuzuweisen, scheitert. Diese Farbe ist nur ohne Einfluss von Lichtquellen sichtbar. Ohne den Einfluss dieser sind aber keinerlei Konturen zu erkennen und die räumliche Vorstellung eines Gegenstands geht verloren.

Texturen sind der Ausweg aus diesem Problem. Um eine Kugel rot zu färben, muss lediglich eine Grafik, zum Beispiel eine \gls{png} Datei, erstellt werden, die in dieser Farbe ausgefüllt ist. Die Größe kann auf ein Minimum (1x1 Pixel) beschränkt werden. Aus der Grafik kann ein \emph{Texture}-Objekt mit Hilfe eines \emph{TextureManagers} erstellt werden. Diese kann nach der Umwandlung in eine \emph{RenderState}-Instanz der Kugel zugewiesen werden. Diese ist daraufhin rot und als Kugel zu erkennen, im Gegensatz zum trivialen Ansatz, ihr nur eine Farbe zuzuweisen.

\paragraph{Transparenz}
\label{sec:Transparenz}
Das Erzeugen durchsichtiger Objekte funktioniert ähnlich wie das oben beschriebene Anlegen einer Textur. Nur bedient man sich hier nicht einer Textur zum Erzeugen einer \emph{RenderState}-Instanz, die dem Objekt zugewiesen wird. Das Mittel der Wahl ist ein \emph{MaterialState}- und ein \emph{BlendingState}-Objekt. Bei der Erstellung der \emph{MaterialState}-Instanz wird unter anderem die Durchsichtigkeit bzw. die Solidität übergeben. Der Wert darf sich im Intervall [0, 1] bewegen. Null bedeutet, dass das Objekt unsichtbar ist, eins hingegen, dass es vollkommen undurchsichtig dargestellt wird.

\subsection{Licht}
\label{sec:Licht}
\gls{jme} unterscheidet in Lichtarten und Lichtquellen. Beide Kategorien sollen hier kurz dargestellt werden.

\subsubsection{Lichtquellen}
\label{sec:Lichtquellen}

Es gibt drei Arten von Lichtquellen. Die erste Art ist die punktförmige Lichtquelle (\emph{PointLight}). Sie besitzt eine Position, von der sich das Licht in alle Richtungen ausbreitet. Die Intensität nimmt standardmäßig mit der Entfernung von der Lichtquelle ab. Weiterhin gibt es das gerichtete Licht (\emph{DirectionalLight}). Es leuchtet unendlich weit und hat keine Position, sondern nur einen Vektor, der angibt, in welche Richtung die Lichtstrahlen fallen. Vergleichbar ist diese Art der Lichtquelle mit der Sonne, von der Erde aus betrachtet. Zwar leuchtet die Sonne nicht unendlich weit, doch für die auf der Erde auftretenden Entfernungen im Verhältnis zur Entfernung zur Sonne kann dieser Fakt vernachlässigt werden. Die dritte Lichtquelle ist ein Lichtkegel (\emph{SpotLight}). Wie der Name es andeutet, ist dies ein Kegel, der alles beleuchtet, was sich in ihm befindet. Seine Leuchtkraft nimmt standardmäßig ebenso ab wie bei einer punktförmigen Lichtquelle.

\subsubsection{Lichtanteile}
\label{sec:Lichtanteile}

Das von den oben beschriebenen Lichtquellen ausgehende Licht besitzt drei Anteile, die vor allem im Hinblick auf ihre Farbe verändert werden können. Zuerst ist da das Raumlicht (\emph{Ambient Light}), das angibt in welcher Intensität und Farbe die Bereiche dargestellt werden sollen, die weder direkt noch indirekt beschienen werden (zum Beispiel Schlagschatten). Als Nächstes gibt es das nichtgerichtete Licht. Es handelt sich hierbei um die diffuse Lichteinstrahlung. Der letzte Lichtanteil ist das reflektierte Licht (\emph{Specular Light}). Dies ist die reflektierte Lichteinstrahlung. Je intensiver diese Art ausgeprägt ist, umso spiegelnder erscheinen Oberflächen.



\section{Google Code}
Bei der Entwicklung des praktischen Anteils dieser Arbeit bestand die Notwendigkeit, die erstellten Daten sicher abzulegen. Dafür eignet sich unter anderem die Arbeit auf einem Terminal-Server, wie er von der Universität der Bundeswehr angeboten wird. Dies ermöglicht, von unterschiedlichen Orten aus und an unterschiedlichen Rechnern zu arbeiten. Nachteil dieser Lösung ist jedoch, dass ein Speichern unterschiedlicher Versionen des erstellten Programms und auch dieser Arbeit nur schwer möglich ist.

Aus diesem Grund wurde für das im Rahmen dieser Arbeit erstellte Programm, aber auch für die schriftliche Ausarbeitung, ein Versionierungssystem verwendet. Aus der Lehre bereits bekannt war Subversion. Es wurde auch hier wegen der nicht mehr notwendigen Einarbeitung gewählt. 

Google stellt auf seinem Portal GoogleCode die Möglichkeit bereit, ein Projekt mit Hilfe von Subversion zu versionieren. Dieser sogenannte \emph{Project Hosting Service} hat zudem noch weitere Vorteile als nur eine komfortable Datensicherung: Der Projektstand kann online dokumentiert werden. Somit wird es möglich, den Betreuer dieser Arbeit auf dem neusten Stand zu halten. Er kann über das Abonnieren eines \gls{rss}-Feeds jederzeit Änderungen Nachverfolgen. Weiterhin bietet Google ein Wiki an, was die Vorstellung und die Dokumentation des Programms ermöglicht. Zusätzlich gibt es eine Downloadverwaltung, in der Testversionen, Screenshots und ähnliches zur Verfügung gestellt werden können.

Wie oben angesprochen, wurde nicht nur der praktische Teil der Arbeit, also der Quellcode, über das Versionierungssystem gesichert. Auch die schriftliche Ausarbeitung in Form des Rohzustands (\TeX-Dateien) und des fertigen \gls{pdf}-Kompilats wurde im Googleprojekt gespeichert.

Zusammenfassend sind die Vorteile des oben geschilderten Vorgehens, dass der Quellcode und die schriftliche Ausarbeitung zuverlässig gesichert werden konnten.  Der Zugriff war ortsunabhängig über das Internet möglich. Mit Hilfe der Versionierung konnte nach Experimenten auf stabile Versionen zurückgegriffen werden. Durch \gls{rss}-Feeds war es dem Betreuer jederzeit möglich, den aktuellen Stand der Arbeit zu betrachten und die im Downloadbereich befindliche Version zu testen.
